# Git

Git — розподілена система керування версіями (СКВ) файлів та спільної роботи. А що ж таке СКВ?
Система контролю версій - це система, що записує зміни у файл або набір файлів протягом деякого часу,
так що ви зможете повернутися до певної версії пізніше.

## Основні стани git

Git має три основних стани, в яких можуть перебувати ваші файли: 
* Збережений у коміті (**comitted**) означає, що дані безпечно збережено в локальній базі даних.
* Змінений (**modified**) означає, що у файл внесено редагування, які ще не збережено в базі даних.
* Індексований (**staged**) стан виникає тоді, коли ви позначаєте змінений файл у поточній версії,
щоб ці зміни ввійшли до наступного знімку коміту.

## Робоча директорія, індекс та директорія Git

У директорії Git система зберігає метадані та базу даних об’єктів вашого проекту. Це найважливіша частина Git,
саме вона копіюється при клонуванні сховища з іншого комп’ютеру.
Робоче дерево — це одна окрема версія проекту, взята зі сховища. Ці файли видобуваються з бази даних
у теці Git та розміщуються на диску для подальшого використання та редагування.
Індекс — це файл, що зазвичай знаходиться в директорії Git і містить інформацію про те, що буде 
збережено у наступному коміті. Також цей файл називають “областю додавання” (staging area), проте ми переважно будемо користуватись технічним терміном Git “індекс”.

![](https://github.com/KrissAyRose/IPZ/blob/dmytro/images/3_stages.png)

Найпростіший процес взаємодії з Git виглядає приблизно так:
1. Ви редагуєте файли у своїй робочій директорії.
2. Вибірково надсилаєте до індексу лише ті зміни, що їх ви бажаєте зберегти в наступному коміті, 
і лише ці зміни буде збережено в індексі.
3. Створюєте коміт: знімок з індексу остаточно зберігається в директорії Git.

## Інсталяція git

### Інсталяція на Linux

Якщо, наприклад, ви використовуєте Fedora (чи будь-який споріднений дистрибутив на базі RPM на кшталт RHEL чи CentOS), 
скористайтеся `dnf`:

`$ sudo dnf install git-all`

Якщо ви використовуєте Debian-подібний дистрибутив, такий як Ubuntu, спробуйте `apt-get`:

`$ sudo apt-get install git-all`

### Інсталяція на Mac

Є декілька способів установки Git на Mac. Найпростіше, встановити Xcode Command Line Tools. На Mavericks (10.9)
або вище, ви можете зробити це просто перший раз виконавши `git` з терміналу.

`$ git --version`

Якщо його досі не встановлено, вам буде запропоновано встановити його.

Якщо ви бажаєте більш свіжу версію, зробіть це за допомогою бінарного інсталятору. Інсталятор для macOS Git 
підтримується та доступний для завантаження на сайті Git http://git-scm.com/download/mac.

### Інсталяція на Windows

Є декілька шляхів встановити Git під Windows. Офіційна збірка доступна для завантаження з сайту Git. 
Просто перейдіть до http://git-scm.com/download/win і завантаження почнеться автоматично.

Щоб встановлення було автоматичним, можете використати Git Chocolatey package: https://chocolatey.org/packages/git.

Ще один простий спосіб встановити Git це встановити GitHub для Windows. 
Установка включає версію командного рядка Git та графічну теж. 
Ви можете завантажити GitHub для Windows за адресою http://windows.github.com.
Інтерфейс цього застосунку можна побачити нижче.

![](https://github.com/KrissAyRose/IPZ/blob/dmytro/images/github_desktop.png)

### Налаштування ім’я користувача

Перше, що ви повинні зробити, коли ви інсталюєте Git - це встановити ім’я користувача та адресу електронної пошти.
Це важливо, тому що кожен коміт в Git використовує цю інформацію, і вона незмінно включена у комміти, які ви робите:

`$ git config --global user.name "John Doe"`

`$ git config --global user.email johndoe@example.com`

Знову ж таки, якщо ви передаєте опцію `--global`, ці налаштування потрібно зробити тільки один раз, тоді Git
завжди буде використовувати цю інформацію для всього, що ви робите у цій системі. Якщо ви хочете, перевизначити
ім’я або адресу електронної пошти для конкретних проектів, ви можете виконати цю ж команду без опції `--global`
в каталозі необхідного проекту. Багато з графічних інструментів допомагають зробити це при першому запуску.

### Перевірка налаштувань

Якщо ви хочете подивитися на свої налаштування, можете скористатися командою `git config --list`,
щоб переглянути всі налаштування, які Git може знайти:
```
$ git config --list
user.name=John Doe
user.email=johndoe@example.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...
```
Ви також можете перевірити значення конкретного ключа виконавши `git config <key>`:

```
$ git config user.name
John Doe
```

## Створення Git-репозиторія

Зазвичай Git репозиторій отримують одним з двох способів:

1. Беруть локальну директорію, що наразі не під контролем версій, та перетворюють її на сховище Git.

2. Звідкілясь клонують існуючий Git репозиторій.

У будь-якому разі ви отримуєте на локальній машині готове до роботи Git сховище.

### Ініціалізація репозиторія в існуючому каталозі

Якщо у вас вже є тека з проектом, що наразі не перебуває під контролем версії, і ви бажаєте почати використовувати з цим проектом Git,
спочатку треба перейти до теки цього проекту. 
Якщо ви ніколи ще цього не робили, команда може трохи відрізнятися в залежності від вашої системи:

для Linux:

`$ cd /home/user/my_project`

для Mac:

`$ cd /Users/user/my_project`

для Windows:

`$ cd /c/user/my_project`

Я працюю на ОС Windows і використовую Git Bash, нижче наведено шлях до теки з проектом:

`$ cd PycharmProjects/IPZ_example/`

У разі успішного переходу до теки з проектом, у консолі буде відображено поточну теку:

`Dima@DESKTOP-DTBVT0A MINGW64 ~/PycharmProjects/IPZ_example (master)`

Після переходу виконуєм:

`$ git init`

Після успішної ініціалізації:

`Initialized empty Git repository in C:/Users/Dima/PycharmProjects/IPZ_example/.git/`

Це створить новий підкаталог .git, який містить всі необхідні файли вашого репозиторія — скелет 
Git-репозиторія. На цей момент, у вашому проекті ще нічого не відстежується.

Якщо ви бажаєте додати існуючі файли під версійний контроль вам слід проіндексувати ці файли і зробити 
перший коміт. Ви можете це зробити за допомогою декількох команд `git add`, що визначають файли, за якими 
ви бажаєте слідкувати, після яких треба виконати `git commit`:

Додамо всі файли з розширенням `.с`

`$ git add *.c`

Додамо файл з ім'ям main.py

`git add main.py`

Зробимо перший коміт:

`$ git commit -m 'Перша версія проекту'`

## Клонування існуючого репозиторія

Якщо ви бажаєте отримати копію існуючого Git репозиторія — наприклад, 
проекту, в якому ви хочете прийняти участь — вам потрібна команда `git clone`.

Щоб клонувати репозиторій треба використати команду `git clone <url>`. Наприклад, 
якщо ви бажаєте зробити клон репозиторію-прикладу IPZ_example, ви можете це зробити так:

`$ git clone https://github.com/shooterdimon/IPZ_example`

Клонування у консолі супроводжуватиметься таким текстом:
```
Cloning into 'IPZ_example'...
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 5 (delta 0), reused 5 (delta 0), pack-reused 0
Unpacking objects: 100% (5/5), done.
```

Це створить директорію під назвою `IPZ_example`, проведе ініціалізацію директорії `.git`, 
забере всі дані для репозиторія, та приведе директорію до стану останньої версії. 
Якщо ви зайдете до щойно створеної директорії `IPZ_example`, ви побачите, що всі файли 
проекту на місці, готові для використання.

Якщо ви бажаєте зробити клон репозиторія в директорію з іншою назвою, ви можете передати 
її як другий параметр команди:

`$ git clone https://github.com/shooterdimon/IPZ_example myIPZ_exmple`

Таким чином створиться директорія під назвою `myIPZ_example`

## Запис змін до репозиторія

кожен файл вашої робочої директорії може бути в одному з двох станів: контрольований (tracked) 
чи неконтрольований (untracked). Контрольовані файли — це файли, що були в останньому знімку. 
Вони можуть бути не зміненими, зміненими або індексованими. Якщо стисло, контрольовані файли — це 
файли, про які Git щось знає.

Неконтрольовані файли — це все інше, будь-які файли у вашій робочій директорії, що не були у вашому 
останньому знімку та не існують у вашому індексі. Якщо ви щойно зробили клон репозиторія, усі ваші 
файли контрольовані та не змінені, адже Git щойно їх отримав, а ви нічого не редагували.

![](https://github.com/KrissAyRose/IPZ/blob/dmytro/images/cycle_changing_status.png)

### Перевірка статусу ваших файлів
Щоб дізнатись, в якому стані ваші файли, варто скористатись командою `git status`. Якщо ви виконаєте 
цю команду відразу після клонування, ви маєте побачити таке:

```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
```

Це означає, що ваша робоча директорія чиста — іншими словами, жоден з контрольованих файлів не змінено. 
Git також не бачить неконтрольованих файлів, інакше він би їх тут вказав. Нарешті, ця команда показує 
вам, в якій ви зараз гілці та інформує вас про те, що вона не розбіглася з такою ж гілкою на сервері. 
Поки що, ця гілка завжди буде “master”, така гілка створюється автоматично.

Припустімо, ви додали новий файл до вашого проекту, простий файл `README.md`. Якщо файл раніше не існував, 
і ви виконаєте `git status`, ви побачите ваш неконтрольований файл так:

```
$ touch README.md
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        ../../.idea/
        README.md
        requirements.txt
        ../Lib/
        ../Scripts/
        ../pyvenv.cfg

nothing added to commit but untracked files present (use "git add" to track)

```

Ви можете бачити, що ваш новий файл README.md неконтрольований, адже він під заголовком
“Untracked files” у статусі. Неконтрольований (untracked) означає, що Git бачить файл, 
якого нема у попередньому знімку (коміті). Git не почне включати його до ваших комітів 
доки ви явно не скажете йому це зробити. Так зроблено щоб ви випадково не почали включати 
генеровані бінарні файли чи інші файли, які ви не збирались включати. 

### Контролювання нових файлів

Щоб почати контролювати новий файл, вам треба використати команду `git add`. Почати контролювати 
файл README.md можна так:

`$ git add README.md`

Якщо ви знову виконаєте команду status, ви побачите, що ваш файл README.md тепер контролюється та 
готовий до включення до коміту:
```
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        ../../.idea/
        requirements.txt
        ../Lib/
        ../Scripts/
        ../pyvenv.cfg

```

Ви можете зрозуміти, що цей файл доданий, бо він під заголовком “Changes to be committed”. 
Якщо ви створите коміт зміни зараз, версія файлу на момент коли ви виконали `git add` буде 
збережена в знімку в історії. Ви можете пригадати, що коли ви виконали `git init` раніше, 
ви потім виконали `git add <файли>` — це було зроблено щоб розпочати контролювати файли у 
вашій директорії. Команда git add приймає шлях файлу або директорії. Якщо це директорія, 
команда додає усі файли в цій директорії рекурсивно.

### Індексування змінених файлів

Змінімо файл, що вже контролюється. Якщо ви зміните файл main.py, що вже 
контролюється, та потім виконаєте команду `git status` знову, ви отримаєте щось на кшталт:

```
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   main.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        ../../.idea/
        requirements.txt
        ../Lib/
        ../Scripts/
        ../pyvenv.cfg

```

Файл `main.py` з’явився під секцією названою “Changes not staged for commit” — це означає, 
що контрольований файл був редагований у робочій директорії проте його не індексували. Щоб 
проіндексувати його, виконайте команду `git add`. `git add` багатоцільова команда — її слід 
використовувати щоб почати контролювати нові файли, щоб додавати файли, та для інших речей, 
наприклад позначання конфліктних файлів як розв’язаних.

Виконаймо `git add` зараз для індексації файлу main.py, а потім знову виконаємо `git status`:

```
$ git add main.py
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   README.md
        modified:   main.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        ../../.idea/
        requirements.txt
        ../Lib/
        ../Scripts/
        ../pyvenv.cfg
```

Обидва файли індексовані та будуть включені до наступного коміту. Припустімо, що саме 
зараз ви пригадали маленьку зміну, яку ви хочете зробити в `main.py` до того, як 
зробити коміт з ним. Ви знову його відкриваєте та редагуєте, і ви готові зробити коміт. 
Втім, виконаймо `git status` ще раз:

```
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   README.md
        modified:   main.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   main.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        ../../.idea/
        requirements.txt
        ../Lib/
        ../Scripts/
        ../pyvenv.cfg

```

Тепер `main.py` є як в індексованих, так і в неіндексованих. Як таке можливо? 
Виявляється, що Git індексує файл саме таким, яким він був, коли ви виконали команду 
`git add`. Якщо ви зараз створите коміт, в історії збережеться версія `main.py`, 
яка була коли ви востаннє викликали `git add`, а не поточна версія файлу з вашої робочої 
директорії, коли ви виконаєте `git commit`. Якщо ви зміните файл після того, як виконаєте 
`git add`, вам треба знову виконати git add щоб проіндексувати останню версію файлу

### Короткий статус

Хоча вивід `git status` доволі вичерпний, він також дещо довгий. Git також пропонує опцію 
короткого перегляду статусу, щоб ви могли побачити свої зміни в більш компактному вигляді. 
Якщо ви виконаєте `git status -s` або `git status --short`, ви отримаєте набагато простіший вивід:

```
$$ git status -s
 M README.md
MM main.py
A  requirements.txt
?? ../../.idea/
?? ../Lib/
?? ../Scripts/
?? ../pyvenv.cfg
```
Нові неконтрольовані файли позначаються `??`, нові індексовані файли позначаються `A`, 
змінені файли позначаються `M` тощо. Результат має дві колонки – ліва містить статус 
індексу, а права містить статус робочої теки. Наприклад у цьому виводі, файл `README.md` 
змінений у робочій директорії, проте не індексований, а файл `requirements.txt` тільки доданий і 
індексований. `main.py` був змінений, індексований та знову змінений, тому є зміни в обох колонках.

### Ігнорування файлів

Буває, що у вас є клас файлів, що ви не хочете щоб Git їх автоматично індексував чи навіть відображав 
як неконтрольовані. Зазвичай це автоматично згенеровані файли, наприклад файли логів або файли вироблені 
вашою системою збірки. У таких випадках, ви можете створити файл `.gitignore`, що містить зразки, яким 
відповідають ці файли. Ось приклад файлу `.gitignore`:

```
$ cat .gitignore
.idea/
```
Перший рядок каже Git ігнорувати директорію `.idea`

Заповнення файлу `.gitignore` вашого нового сховища до початку праці зазвичай гарна думка, адже це допоможе вам випадково не додати файли, які ви не хочете додавати до репозиторія Git.

Правила для взірців, які ви можете додати до файлу `.gitignore`:

* Порожні рядки та рядки, що починаються з `#`, ігноруються.

* Стандартні ґлоб взірці працюють, і будуть застосовані для всього робочого дерева рекурсивно.

* Ви можете почати взірець з прямої похилої риски (`/`) щоб уникнути рекурсії.

* Ви можете завершити взірець похилою рискою (`/`) щоб позначити директорію.

* Ви можете відкинути взірець, якщо почнете його зі знаку оклику (`!`).

Ґлоб (glob) взірці – це ніби спрощені регулярні вирази, що їх використовують оболонки. 
Зірочка (`*`) відповідає нулю або більше символам. `[абв]` відповідає будь-якому з символів 
всередині квадратних дужок (у цьому випадку а, б або в). Знак питання (`?`) відповідає одному 
символу. Квадратні дужки з символами, що розділені дефісом (`[0-9]`) відповідають будь-якому 
символу між ними (у даному випадку від 0 до 9). Ви можете використовувати дві зірочки щоб 
позначити вкладені директорії: `a/**/z` відповідає `a/z`, `a/b/z`, `a/b/c/z` тощо.

Ось ще один приклад файлу `.gitignore`:

```
$ cat .gitignore
# Ігнорувати директорію Lib
Lib/

# Ігнорувати директорію Lib
Scripts/

# Ігнорувати всі файли з розширенням .cfg
*.cfg

```







```
git push -u origin master
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 4 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (5/5), 606 bytes | 606.00 KiB/s, done.
Total 5 (delta 0), reused 0 (delta 0)
To https://github.com/shooterdimon/IPZ_example.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.
```







